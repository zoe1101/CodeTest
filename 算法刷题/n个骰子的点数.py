'''
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
s={2,3,4,5,6,7,8,9,10,11,12}


思路：动态规划

通过题目我们知道一共投掷 n 枚骰子，那最后一个阶段很显然就是：当投掷完 nn 枚骰子后，各个点数出现的次数。
注意，这里的点数指的是前 n 枚骰子的点数和，而不是第 nn 枚骰子的点数，下文同理。

首先用数组的第一维来表示阶段，也就是投掷完了几枚骰子。
然后用第二维来表示投掷完这些骰子后，可能出现的点数。
数组的值就表示，该阶段各个点数出现的次数。
所以状态表示就是这样的：dp[i][j] ，表示投掷完 i枚骰子后，点数 j的出现次数。


声明一个二维数组 dpdp ，dp[i][j] 代表前 i 个骰子的点数和 j 的概率，并执行状态转移。而由于 dp[i] 仅由 dp[i-1]递推得出，为降低空间复杂度，只建立两个一维数组 dp , tmp 交替前进即可。

'''
from typing import List


class Solution:
    def dicesProbability(self, n: int) -> List[float]:
        dp=[1/6]*6
        for i in range(2,n+1):
            tmp=[0]*(5*i+1)  ## (5*i+1) 代表，i颗骰子结果和[i,6i]的个数(6i-i)+1
            for j in range(len(dp)):
                for k in range(6):
                    tmp[j+k]+=dp[j]/6   ##dp[j]*(1/6)
            dp=tmp
        return dp

